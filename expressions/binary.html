<!doctype html>
<html lang="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.19.0" />
    <title>Parsing Binary Operations</title>
    
    
    <meta name="description" content="docs" />
    
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="../creative-scala.css" />
    <script> /* for avoiding page load transitions */</script>
</head>

<body>
    <nav id="topbar"><p><a href="index.html">←</a></p>
<p><a href="https://creativescala.github.io/case-study-parser/index.html">Case Study: Parsing</a></p>
<p><a href="recursion.html">→</a></p></nav>
    <nav id="sidebar">
        <ul class="nav-list">
          <li class="level1"><a href="../index.html">Case Study: Parsing</a></li>
          <li class="level1"><a href="../basics.html">The Simplest Parser</a></li>
          <li class="level1"><a href="../testing.html">Testing Parsers</a></li>
          <li class="level1"><a href="../type-classes/index.html">Designing Using Type Classes</a></li>
          <li class="level2"><a href="../type-classes/functor.html">Functor</a></li>
          <li class="level2"><a href="../type-classes/monoid.html">Monoid</a></li>
          <li class="level2"><a href="../type-classes/applicative.html">Applicative</a></li>
          <li class="level2"><a href="../type-classes/monad.html">Monad</a></li>
          <li class="level2"><a href="../type-classes/kleene.html">Kleene Star</a></li>
          <li class="level2"><a href="../type-classes/conclusions.html">Conclusions</a></li>
          <li class="level1"><a href="index.html">Parsing Expressions</a></li>
          <li class="level2 active"><a href="#">Parsing Binary Operations</a></li>
          <li class="level2"><a href="recursion.html">Recursive Expressions</a></li>
          <li class="level2"><a href="json.html">Parsing JSON</a></li>
          <li class="level2"><a href="conclusions.html">Conclusions</a></li>
          <li class="level1"><a href="../optimization/index.html">Benchmarks and Optimization</a></li>
          <li class="level2"><a href="../optimization/benchmark.html">Benchmarking</a></li>
          <li class="level2"><a href="../optimization/design.html">Designing for Performance</a></li>
          <li class="level2"><a href="../optimization/internals.html">Internal Optimizations</a></li>
          <li class="level2"><a href="../optimization/conclusions.html">Conclusions</a></li>
          <li class="level1"><a href="../context/index.html">Parsers in Context</a></li>
          <li class="level2"><a href="../context/parser-combinators.html">Parser Combinators</a></li>
          <li class="level2"><a href="../context/evaluation.html">Controlling Order of Evaluation</a></li>
          <li class="level1"><a href="../references.html">References</a></li>
        </ul>
    </nav>

    <div id="content">
        <main class="content">
            <h1 id="parsing-binary-operations" class="title">Parsing Binary Operations</h1>
            <p>We&#39;ll start by parsing expressions that contain a single operator, such as <code>+</code>, that has two arguments. For example, we&#39;ll parse <code>4 + 5</code> or <code>x * 3</code>, but not <code>4 + x * 3</code>.</p>
            <p>This already introduces quite a bit of complexity. In the two examples above we have:</p>
            <ul>
              <li>literal numbers such as <code>3</code> and <code>5</code>;</li>
              <li>a variable, <code>x</code>; and</li>
              <li>the binary operators <code>+</code> and <code>*</code>.</li>
            </ul>
            <p>We&#39;ll need to define parsers for each of these components and then compose them together to produce our overall parser.</p>
            <p>Let&#39;s start with the atomic elements: numbers and variables. We can use the following definitions:</p>
            <ul>
              <li>a literal number is 1 or more digits; and</li>
              <li>a variable is 1 or more alphabetic characters.</li>
            </ul>
            <p>This naturally requires us to define digits and alphabetic characters:</p>
            <ul>
              <li>a digit is the character <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, or <code>9</code>; and</li>
              <li>an alphabetic character is one of the lowercase characters between <code>a</code> and <code>z</code>. </li>
            </ul>
            <p>This is sufficient for us to start writing parsers. I&#39;ll get you started.</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">alphabetic</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] =
  </span><span class="type-name">List</span><span>(</span><span class="char-literal">&#39;a&#39;</span><span>, </span><span class="char-literal">&#39;b&#39;</span><span>, </span><span class="char-literal">&#39;c&#39;</span><span>, </span><span class="char-literal">&#39;d&#39;</span><span>, </span><span class="char-literal">&#39;e&#39;</span><span>, </span><span class="char-literal">&#39;f&#39;</span><span>, </span><span class="char-literal">&#39;g&#39;</span><span>, </span><span class="char-literal">&#39;h&#39;</span><span>, </span><span class="char-literal">&#39;i&#39;</span><span>, </span><span class="char-literal">&#39;j&#39;</span><span>, </span><span class="char-literal">&#39;k&#39;</span><span>, </span><span class="char-literal">&#39;l&#39;</span><span>, </span><span class="char-literal">&#39;m&#39;</span><span>,
       </span><span class="char-literal">&#39;n&#39;</span><span>, </span><span class="char-literal">&#39;o&#39;</span><span>, </span><span class="char-literal">&#39;p&#39;</span><span>, </span><span class="char-literal">&#39;q&#39;</span><span>, </span><span class="char-literal">&#39;r&#39;</span><span>, </span><span class="char-literal">&#39;s&#39;</span><span>, </span><span class="char-literal">&#39;t&#39;</span><span>, </span><span class="char-literal">&#39;u&#39;</span><span>, </span><span class="char-literal">&#39;v&#39;</span><span>, </span><span class="char-literal">&#39;w&#39;</span><span>, </span><span class="char-literal">&#39;x&#39;</span><span>, </span><span class="char-literal">&#39;y&#39;</span><span>, </span><span class="char-literal">&#39;z&#39;</span><span>)
    .</span><span class="identifier">foldLeft</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">fail</span><span>[</span><span class="type-name">String</span><span>]){ (</span><span class="identifier">parser</span><span>, </span><span class="identifier">char</span><span>) =&gt;
      </span><span class="identifier">parser</span><span>.</span><span class="identifier">orElse</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">string</span><span>(</span><span class="identifier">char</span><span>.</span><span class="identifier">toString</span><span>))
    }
    
</span><span class="keyword">val</span><span> </span><span class="identifier">variable</span><span> = </span><span class="identifier">alphabetic</span><span>.</span><span class="identifier">and</span><span>(</span><span class="identifier">alphabetic</span><span>.</span><span class="identifier">repeat</span><span>)</span></code></pre>
            <p>Now you go ahead and implement parsers for digits and literals.</p>
            
            <h3 id="abstract-syntax-trees" class="section">Abstract Syntax Trees</h3>
            <p>Now we can parse very simple expressions, we should create a data structure that stores the result of our parse. In the compiler literature these data structures are known as <em>abstract syntax trees</em> (ASTs). They represent the syntax of the input we parsed, and are usually organized as a tree. In Scala we usually represent abstract syntax trees as algebraic data types (ADTs).</p>
            <p>Here&#39;s an AST, which is also an ADT, for representing the expressions we described above:</p>
            <pre><code class="nohighlight"><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expression</span><span> {
  </span><span class="keyword">import</span><span> </span><span class="type-name">Expression</span><span>.</span><span class="identifier">_</span><span>

  </span><span class="keyword">def</span><span> +(</span><span class="identifier">that</span><span>: </span><span class="type-name">Expression</span><span>): </span><span class="type-name">Expression</span><span> =
    </span><span class="type-name">Add</span><span>(</span><span class="keyword">this</span><span>, </span><span class="identifier">that</span><span>)

  </span><span class="keyword">def</span><span> *(</span><span class="identifier">that</span><span>: </span><span class="type-name">Expression</span><span>): </span><span class="type-name">Expression</span><span> =
    </span><span class="type-name">Multiply</span><span>(</span><span class="keyword">this</span><span>, </span><span class="identifier">that</span><span>)
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Expression</span><span> {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">literal</span><span>(</span><span class="identifier">value</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">Expression</span><span> = </span><span class="type-name">Literal</span><span>(</span><span class="identifier">value</span><span>)
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">variable</span><span>(</span><span class="identifier">value</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Expression</span><span> = </span><span class="type-name">Variable</span><span>(</span><span class="identifier">value</span><span>)

  </span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Literal</span><span>(</span><span class="identifier">value</span><span>: </span><span class="type-name">Int</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expression</span><span>
  </span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Variable</span><span>(</span><span class="identifier">value</span><span>: </span><span class="type-name">String</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expression</span><span>
  </span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Add</span><span>(</span><span class="identifier">left</span><span>: </span><span class="type-name">Expression</span><span>, </span><span class="identifier">right</span><span>: </span><span class="type-name">Expression</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expression</span><span>
  </span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Multiply</span><span>(</span><span class="identifier">left</span><span>: </span><span class="type-name">Expression</span><span>, </span><span class="identifier">right</span><span>: </span><span class="type-name">Expression</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expression</span><span>
}</span></code></pre>
            <p>Notice that I&#39;ve made a bit of effort to make this more pleasant to use. The methods <code>+</code> and <code>*</code> make it easy to construct compound expressions. The &quot;smart constructors&quot; on the companion object return objects of type <code>Expression</code>, which avoids some issues with type inference that you probably won&#39;t even realize we&#39;ve side-stepped.</p>
            <p>Also note that this AST is more expressive than the expressions we&#39;re trying to parse. We&#39;re only parsing expressions that contain a single operator, but our AST can represent arbitrarily nested operators.</p>
            <p>Update your parsers so they produce values of type <code>Expression</code> on a successful parse. We don&#39;t yet have parsers for compound expressions (addition and multiplication) but that&#39;s our next step.</p>
            
            <h3 id="binary-operations" class="section">Binary Operations</h3>
            <p>Our next step is to parse the binary operations <code>+</code> and <code>*</code>. You might already see how to do this. If so, try it yourself before reading on. If not, I&#39;ll show how to implement a parser for addition. Multiplication is a straightforward modification of it.</p>
            <p>An addition is a literal or variable, followed by the addition sign, followed by another literal or variable. The actually not entirely correct. There can be whitespace separating any of these elements, and our parser needs to account for that. </p>
            <p>Here&#39;s my implementation.</p>
            <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">charIn</span><span>(</span><span class="identifier">char</span><span>: </span><span class="type-name">Char</span><span>, </span><span class="identifier">chars</span><span>: </span><span class="type-name">Char</span><span>*): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] =
  </span><span class="identifier">chars</span><span>.</span><span class="identifier">foldLeft</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">string</span><span>(</span><span class="identifier">char</span><span>.</span><span class="identifier">toString</span><span>)){ (</span><span class="identifier">parser</span><span>, </span><span class="identifier">char</span><span>) =&gt;
    </span><span class="identifier">parser</span><span>.</span><span class="identifier">orElse</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">string</span><span>(</span><span class="identifier">char</span><span>.</span><span class="identifier">toString</span><span>)) 
  }
  
</span><span class="keyword">val</span><span> </span><span class="identifier">whitespace</span><span> = </span><span class="identifier">charIn</span><span>(</span><span class="char-literal">&#39; &#39;</span><span>, </span><span class="char-literal">&#39;</span><span class="escape-sequence">\t</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;</span><span class="escape-sequence">\n</span><span class="char-literal">&#39;</span><span>).</span><span class="identifier">repeat</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">factor</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Expression</span><span>] = </span><span class="identifier">literal</span><span>.</span><span class="identifier">orElse</span><span>(</span><span class="identifier">variable</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">addition</span><span> = (</span><span class="identifier">factor</span><span>, (</span><span class="identifier">whitespace</span><span> *&gt; </span><span class="identifier">charIn</span><span>(</span><span class="char-literal">&#39;+&#39;</span><span>) &lt;* </span><span class="identifier">whitespace</span><span>), </span><span class="identifier">factor</span><span>)
                 .</span><span class="identifier">mapN</span><span>((</span><span class="identifier">l</span><span>, </span><span class="identifier">_</span><span>, </span><span class="identifier">r</span><span>) =&gt; </span><span class="identifier">l</span><span> + </span><span class="identifier">r</span><span>)</span></code></pre>
            <p>A few points:</p>
            <ul>
              <li>I defined a parser <code>factor</code> to refer to a literal or a variable.</li>
              <li>I created a utility method, <code>charIn</code>, to make creating parsers easier.</li>
              <li>I&#39;ve also used <code>mapN</code>, <code>*&gt;</code>, and <code>&lt;*</code>, which are methods defined by Cats for all applicatives, to make the code a bit more compact. You should be familiar with <code>mapN</code>, but <code>*&gt;</code> and <code>&lt;*</code> may be new to you. The way to read them is as binary operations that only keep the value pointed to by the arrow. So in <code>whitespace *&gt; charIn(&#39;+&#39;) &lt;* whitespace</code> I only keep the result of parsing the <code>+</code> and discard the result of parsing any whitespace. These methods are on the edge for me: they are not so well known that I feel confident using them in all codebases. In this context, though, it&#39;s an opportunity for you learn so I&#39;ve used them.</li>
            </ul>
            
            <h3 id="lessons-on-api-design" class="section">Lessons on API Design</h3>
            <p>Our work so far as exposed some flaws in our current design. Here are the issues I noted:</p>
            <ol class="arabic">
              <li>
                <p>We have to use a <code>Parser[String]</code> just to look for a single <code>Char</code>. A <code>String</code> contains 0 or more characters, while a <code>Char</code> is exactly one character. It would be better if could use the more precise type <code>Char</code> when we want exactly one <code>Char</code>.</p>
              </li>
              <li>
                <p><code>charIn</code> is the kind of method that should be provided by our parser library, as it&#39;s a case that frequently occurs. There are at least two variants we can envisage: one where we specify the characters we&#39;re looking for, and one where we specify a predicate that is <code>true</code> if the character is one we&#39;re looking for.</p>
              </li>
              <li>
                <p>The construction <code>parser.and(parser.repeat)</code> is an inconvenient way to express one or more repetitions of a parser, and is certainly a bit opaque to someone new to the library. This operation is sometimes known as the Kleene plus and is very common. We should consider directly supporting it.</p>
              </li>
            </ol>
            <p>Designing using type classes gets us some of the way to a good API, but not all of the way. We still need domain specific methods like the Kleene star. Working on examples is a good way to discover missing methods, as we&#39;ve done here.</p>
            <p>I added the following constructors:</p>
            <ul>
              <li><code>Parser.char(value: Char): Parser[Char]</code></li>
              <li><code>Parser.charIn(char: Char, chars: Char*): Parser[Char]</code></li>
              <li><code>Parser.stringIn(string: String, strings: String*): Parser[String]</code></li>
            </ul>
            <p>To keep the interpreter small I haven&#39;t directly reified <code>charIn</code> or <code>stringIn</code>, instead implementing them in terms of simpler methods.</p>
            <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">charIn</span><span>(</span><span class="identifier">char</span><span>: </span><span class="type-name">Char</span><span>, </span><span class="identifier">chars</span><span>: </span><span class="type-name">Char</span><span>*): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Char</span><span>] =
  </span><span class="identifier">chars</span><span>.</span><span class="identifier">foldLeft</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">char</span><span>(</span><span class="identifier">char</span><span>)) { (</span><span class="identifier">parser</span><span>, </span><span class="identifier">char</span><span>) =&gt;
    </span><span class="identifier">parser</span><span>.</span><span class="identifier">orElse</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">char</span><span>(</span><span class="identifier">char</span><span>))
  }

</span><span class="keyword">def</span><span> </span><span class="declaration-name">stringIn</span><span>(</span><span class="identifier">string</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">strings</span><span>: </span><span class="type-name">String</span><span>*): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] =
  </span><span class="identifier">strings</span><span>.</span><span class="identifier">foldLeft</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">string</span><span>(</span><span class="identifier">string</span><span>)) { (</span><span class="identifier">parser</span><span>, </span><span class="identifier">string</span><span>) =&gt;
    </span><span class="identifier">parser</span><span>.</span><span class="identifier">orElse</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">string</span><span>(</span><span class="identifier">string</span><span>))
  }</span></code></pre>
            <p>I then reworked the <code>repeat</code> combinator:</p>
            <ul>
              <li>I added <code>repeatAtLeast(minimum: Int)</code>, which allows the caller to specify the minimum number of repeats for a succesful parse;</li>
              <li>I added <code>zeroOrMore</code> and <code>oneOrMore</code> as special cases of <code>repeatAtLeast</code>; and</li>
              <li>I added <code>repeatBetween(min: Int, max: Int)</code> to allow specifying a maximum number of repeats.</li>
            </ul>
            <p>As with <code>charIn</code> and <code>stringIn</code>, I implemented <code>repeatAtLeast</code> in terms of the existing <code>ParserRepeat</code> reificiation and <code>and</code>.</p>
            <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">repeatAtLeast</span><span>(</span><span class="identifier">minimum</span><span>: </span><span class="type-name">Int</span><span>)(</span><span class="keyword">implicit</span><span> </span><span class="identifier">m</span><span>: </span><span class="type-name">Monoid</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>] = {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">loop</span><span>(</span><span class="identifier">count</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>] =
    </span><span class="keyword">if</span><span> (</span><span class="identifier">count</span><span> == </span><span class="number-literal">0</span><span>) </span><span class="type-name">ParserRepeat</span><span>(</span><span class="keyword">this</span><span>, </span><span class="identifier">m</span><span>)
    </span><span class="keyword">else</span><span> </span><span class="type-name">ParserAnd</span><span>(</span><span class="keyword">this</span><span>, </span><span class="identifier">loop</span><span>(</span><span class="identifier">count</span><span> - </span><span class="number-literal">1</span><span>), </span><span class="identifier">m</span><span>)

  </span><span class="identifier">loop</span><span>(</span><span class="identifier">minimum</span><span>)
}</span></code></pre>
            <p>As we add a richer API to our library we&#39;ll find there is a tension between keeping the internals simpler by implementing new methods in terms of existing ones, and improving performance by taking advantage of the additional information we have when implementing a new method directly. We&#39;ll see more of this in the <a href="../optimization/index.html">chapter on optimization</a>.</p>
            <p class="nextPage"><a href="recursion.html">Recursive Expressions→</a></p>
        </main>
        <footer>Creative Scala is copyright Noel Welsh</footer>
    </div>

    </div>
</body>

</html>