<!doctype html>
<html lang="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.19.0" />
    <title>Parsing Binary Operations</title>
    
    
    <meta name="description" content="docs" />
    
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="../creative-scala.css" />
    <script> /* for avoiding page load transitions */</script>
</head>

<body>
    <nav id="topbar"><p><a href="index.html">‚Üê</a></p>
<p><a href="../../">Case Study: Parsing</a></p>
<p></p></nav>
    <nav id="sidebar">
        <ul class="nav-list">
          <li class="level1"><a href="../index.html">Case Study: Parsing</a></li>
          <li class="level1"><a href="../basics.html">The Simplest Parser</a></li>
          <li class="level1"><a href="../testing.html">Testing Parsers</a></li>
          <li class="level1"><a href="../type-classes/index.html">Designing Using Type Classes</a></li>
          <li class="level2"><a href="../type-classes/functor.html">Functor</a></li>
          <li class="level2"><a href="../type-classes/monoid.html">Monoid</a></li>
          <li class="level2"><a href="../type-classes/applicative.html">Applicative</a></li>
          <li class="level2"><a href="../type-classes/monad.html">Monad</a></li>
          <li class="level2"><a href="../type-classes/kleene.html">Kleene Star</a></li>
          <li class="level2"><a href="../type-classes/conclusions.html">Conclusions</a></li>
          <li class="level1"><a href="../references.html">References</a></li>
          <li class="level1"><a href="index.html">Parsing Expressions</a></li>
          <li class="level2 active"><a href="#">Parsing Binary Operations</a></li>
        </ul>
    </nav>

    <div id="content">
        <main class="content">
            <h1 id="parsing-binary-operations" class="title">Parsing Binary Operations</h1>
            <p>We&#39;ll start by parsing expressions that contain a single operator, such as <code>+</code>, that has two arguments. For example, we&#39;ll parse <code>4 + 5</code> or <code>x * 3</code>, but not <code>4 + x * 3</code>.</p>
            <p>This already introduces quite a bit of complexity. In the two examples above we have:</p>
            <ul>
              <li>literal numbers such as <code>3</code> and <code>5</code>;</li>
              <li>a variable, <code>x</code>; and</li>
              <li>the binary operators <code>+</code> and <code>*</code>.</li>
            </ul>
            <p>We&#39;ll need to define parsers for each of these components and then compose them together to produce our overall parser.</p>
            <p>Let&#39;s start with the atomic elements: numbers and variables. We can use the following definitions:</p>
            <ul>
              <li>a literal number is 1 or more digits; and</li>
              <li>a variable is 1 or more alphabetic characters.</li>
            </ul>
            <p>This naturally requires us to define digits and alphabetic characters:</p>
            <ul>
              <li>a digit is the character <code>0</code>, <code>1</code>, <code>2,</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, or <code>9</code>; and</li>
              <li>an alphabetic character is one of the lowercase characters between <code>a</code> and <code>z</code>. </li>
            </ul>
            <p>This is sufficient for us to start writing parsers. I&#39;ll get you started.</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">alphabetic</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] =
  </span><span class="type-name">List</span><span>(</span><span class="identifier">`a`</span><span>, </span><span class="identifier">`b`</span><span>, </span><span class="identifier">`c`</span><span>, </span><span class="identifier">`d`</span><span>, </span><span class="identifier">`e`</span><span>, </span><span class="identifier">`f`</span><span>, </span><span class="identifier">`g`</span><span>, </span><span class="identifier">`h`</span><span>, </span><span class="identifier">`i`</span><span>, </span><span class="identifier">`j`</span><span>, </span><span class="identifier">`k`</span><span>, </span><span class="identifier">`l`</span><span>, </span><span class="identifier">`m`</span><span>,
       </span><span class="identifier">`n`</span><span>, </span><span class="identifier">`o`</span><span>, </span><span class="identifier">`p`</span><span>, </span><span class="identifier">`q`</span><span>, </span><span class="identifier">`r`</span><span>, </span><span class="identifier">`s`</span><span>, </span><span class="identifier">`t`</span><span>, </span><span class="identifier">`u`</span><span>, </span><span class="identifier">`v`</span><span>, </span><span class="identifier">`w`</span><span>, </span><span class="identifier">`x`</span><span>, </span><span class="identifier">`y`</span><span>, </span><span class="identifier">`z`</span><span>)
    .</span><span class="identifier">foldLeft</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">fail</span><span>[</span><span class="type-name">String</span><span>]){ (</span><span class="identifier">parser</span><span>, </span><span class="identifier">char</span><span>) =&gt;
      </span><span class="identifier">parser</span><span>.</span><span class="identifier">orElse</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">string</span><span>(</span><span class="identifier">char</span><span>.</span><span class="identifier">toString</span><span>))
    }
    
</span><span class="keyword">val</span><span> </span><span class="identifier">variable</span><span> = </span><span class="identifier">alphabetic</span><span>.</span><span class="identifier">and</span><span>(</span><span class="identifier">alphabetic</span><span>.</span><span class="identifier">repeat</span><span>)</span></code></pre>
            <p>Now you go ahead and implement parsers for digits and literals.</p>
            
            <h3 id="abstract-syntax-trees" class="section">Abstract Syntax Trees</h3>
            <p>Now we can parse very very simple expressions, we should create a data structure that stores the result of our parse. In the compiler literature these data structures are known as <em>abstract syntax trees</em> (ASTs). They represent the syntax of the input we parsed, and are usually organized as a tree. In Scala we usually represent abstract syntax trees as algebraic data types (ADTs).</p>
            <p>Here&#39;s an AST, which is also an ADT, for representing the expressions we described above:</p>
            <pre><code class="nohighlight"><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expression</span><span> {
  </span><span class="keyword">import</span><span> </span><span class="type-name">Expression</span><span>.</span><span class="identifier">_</span><span>

  </span><span class="keyword">def</span><span> +(</span><span class="identifier">that</span><span>: </span><span class="type-name">Expression</span><span>): </span><span class="type-name">Expression</span><span> =
    </span><span class="type-name">Add</span><span>(</span><span class="keyword">this</span><span>, </span><span class="identifier">that</span><span>)

  </span><span class="keyword">def</span><span> *(</span><span class="identifier">that</span><span>: </span><span class="type-name">Expression</span><span>): </span><span class="type-name">Expression</span><span> =
    </span><span class="type-name">Multiply</span><span>(</span><span class="keyword">this</span><span>, </span><span class="identifier">that</span><span>)
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Expression</span><span> {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">literal</span><span>(</span><span class="identifier">value</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">Expression</span><span> = </span><span class="type-name">Literal</span><span>(</span><span class="identifier">value</span><span>)
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">variable</span><span>(</span><span class="identifier">value</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Expression</span><span> = </span><span class="type-name">Variable</span><span>(</span><span class="identifier">value</span><span>)

  </span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Literal</span><span>(</span><span class="identifier">value</span><span>: </span><span class="type-name">Int</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expression</span><span>
  </span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Variable</span><span>(</span><span class="identifier">value</span><span>: </span><span class="type-name">Int</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expression</span><span>
  </span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Add</span><span>(</span><span class="identifier">left</span><span>: </span><span class="type-name">Expression</span><span>, </span><span class="identifier">right</span><span>: </span><span class="type-name">Expression</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expression</span><span>
  </span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Multiply</span><span>(</span><span class="identifier">left</span><span>: </span><span class="type-name">Expression</span><span>, </span><span class="identifier">right</span><span>: </span><span class="type-name">Expression</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expression</span><span>
}</span></code></pre>
            <p>Notice that I&#39;ve made a bit of effort to make this more pleasant to use. The methods <code>+</code> and <code>*</code> make it easy to construct compound expressions. The &quot;smart constructors&quot; on the companion object return objects of type <code>Expression</code>, which avoids some issues with type inference that you probably won&#39;t even realize we&#39;ve side-stepped.</p>
            <p>Also note that this AST is more expressive than the expressions we&#39;re trying to parse. We&#39;re only parsing expressions that contain a single operator, but our AST can represent arbitrarily nested operators.</p>
            <p>Update your parsers so they produce values of type <code>Expression</code> on a successful parse. We don&#39;t yet have parsers for compound expressions (addition and multiplication) but that&#39;s our next step.</p>
            
            <h3 id="binary-operations" class="section">Binary Operations</h3>
            <p>Our next step is to parse the binary operations <code>+</code> and <code>*</code>. You might already see how to do this. If so, try it yourself before reading on. If not, I&#39;ll show how to implement a parser for addition.</p>
            <p>An addition is a literal or variable, followed by the addition sign, followed by another literal or variable. The actually not entirely correct. There can be whitespace separating any of these elements, and our parser needs to account for that. </p>
            <p>Here&#39;s my implementation.</p>
            <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">oneOf</span><span>(</span><span class="identifier">char</span><span>: </span><span class="type-name">Char</span><span>, </span><span class="identifier">chars</span><span>: </span><span class="type-name">Chars</span><span>*): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] =
  </span><span class="identifier">chars</span><span>.</span><span class="identifier">foldLeft</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">string</span><span>(</span><span class="identifier">char</span><span>.</span><span class="identifier">toString</span><span>)){ (</span><span class="identifier">parser</span><span>, </span><span class="identifier">char</span><span>) =&gt;
    </span><span class="identifier">parser</span><span>.</span><span class="identifier">orElse</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">string</span><span>(</span><span class="identifier">char</span><span>.</span><span class="identifier">toString</span><span>)) 
  }
  
</span><span class="keyword">val</span><span> </span><span class="identifier">whitespace</span><span> = </span><span class="identifier">oneOf</span><span>(</span><span class="char-literal">&#39; &#39;</span><span>, </span><span class="char-literal">&#39;</span><span class="escape-sequence">\t</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;</span><span class="escape-sequence">\n</span><span class="char-literal">&#39;</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">factor</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Expression</span><span>] = </span><span class="identifier">literal</span><span>.</span><span class="identifier">orElse</span><span>(</span><span class="identifier">variable</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">addition</span><span> = (</span><span class="identifier">factor</span><span>, (</span><span class="identifier">whitespace</span><span> *&gt; </span><span class="identifier">oneOf</span><span>(</span><span class="char-literal">&#39;+&#39;</span><span>) &lt;* </span><span class="identifier">whitespace</span><span>), </span><span class="identifier">factor</span><span>)
                 .</span><span class="identifier">mapN</span><span>((</span><span class="identifier">l</span><span>, </span><span class="identifier">_</span><span>, </span><span class="identifier">r</span><span>) =&gt; </span><span class="identifier">l</span><span> + </span><span class="identifier">r</span><span>)</span></code></pre>
            <p>Notice how defined a utility method, <code>oneOf</code>, to make creating parsers easier. I&#39;ve also used <code>mapN</code>, <code>*&gt;</code>, and <code>&lt;*</code>, which are methods defined by Cats for all Applicatives, to make the code a bit more compact.</p>
            
            <h3 id="lessons-on-api-design" class="section">Lessons on API Design</h3>
            
        </main>
        <footer>Creative Scala is copyright Noel Welsh</footer>
    </div>

    </div>
</body>

</html>