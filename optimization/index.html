<!doctype html>
<html lang="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.19.0" />
    <title>Benchmarks and Optimization</title>
    
    
    <meta name="description" content="docs" />
    
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="../creative-scala.css" />
    <script> /* for avoiding page load transitions */</script>
</head>

<body>
    <nav id="topbar"><p><a href="../expressions/conclusions.html">←</a></p>
<p><a href="../../">Case Study: Parsing</a></p>
<p><a href="benchmark.html">→</a></p></nav>
    <nav id="sidebar">
        <ul class="nav-list">
          <li class="level1"><a href="../index.html">Case Study: Parsing</a></li>
          <li class="level1"><a href="../basics.html">The Simplest Parser</a></li>
          <li class="level1"><a href="../testing.html">Testing Parsers</a></li>
          <li class="level1"><a href="../type-classes/index.html">Designing Using Type Classes</a></li>
          <li class="level2"><a href="../type-classes/functor.html">Functor</a></li>
          <li class="level2"><a href="../type-classes/monoid.html">Monoid</a></li>
          <li class="level2"><a href="../type-classes/applicative.html">Applicative</a></li>
          <li class="level2"><a href="../type-classes/monad.html">Monad</a></li>
          <li class="level2"><a href="../type-classes/kleene.html">Kleene Star</a></li>
          <li class="level2"><a href="../type-classes/conclusions.html">Conclusions</a></li>
          <li class="level1"><a href="../expressions/index.html">Parsing Expressions</a></li>
          <li class="level2"><a href="../expressions/binary.html">Parsing Binary Operations</a></li>
          <li class="level2"><a href="../expressions/recursion.html">Recursive Expressions</a></li>
          <li class="level2"><a href="../expressions/json.html">Parsing JSON</a></li>
          <li class="level2"><a href="../expressions/conclusions.html">Conclusions</a></li>
          <li class="level1 active"><a href="#">Benchmarks and Optimization</a></li>
          <li class="level2"><a href="benchmark.html">Benchmarking</a></li>
          <li class="level2"><a href="design.html">Designing for Performance</a></li>
          <li class="level1"><a href="../context/index.html">Parsers in Context</a></li>
          <li class="level2"><a href="../context/evaluation.html">Controlling Order of Evaluation</a></li>
          <li class="level1"><a href="../references.html">References</a></li>
        </ul>
    </nav>

    <div id="content">
        <main class="content">
            <h1 id="benchmarks-and-optimization" class="title">Benchmarks and Optimization</h1>
            <p>In this section we&#39;ll benchmark our parser combinator library, and use our benchmarks to optimize our implementation and inform our API design. Recall there are three main problem solving strategies:</p>
            <ol class="arabic">
              <li>reasoning from models;</li>
              <li>reasoning from data; and</li>
              <li>appeals to authority.</li>
            </ol>
            <p>In previous sections our main tool has been reasoning from models: we&#39;ve being using reificiation, following types, and so on, which all come from formal models of code. We&#39;ve mixed in a little bit of API design driven from experience using our library and from existing work on parsers, corresponding to reasoning from data and appeals to authority respectively. </p>
            <p>In this section we&#39;ll work much more with reasoning from data, using our benchmarks to drive development. There is still an element of reasoning from models here, as the choice of benchmarks to run and optimizations to attempt is driven from a model of code performance.</p>
            <p>Our benchmarks will use <a href="https://github.com/openjdk/jmh">JMH</a>, which we&#39;ll interface with via <a href="https://github.com/sbt/sbt-jmh">sbt-jmh</a>. JMH is standard for benchmarking on the JVM, but it&#39;s not my favourite project. To the best of my knowledge the only official documentation for JMH is in the comments in the <a href="https://github.com/openjdk/jmh/tree/master/jmh-samples/src/main/java/org/openjdk/jmh/samples">JMH samples</a> and the <a href="https://javadoc.io/doc/org.openjdk.jmh/jmh-core/latest/index.html">JMH Javadoc</a>. It&#39;s not a great state of affairs. </p>
            <p>Here&#39;s a quick rundown of how JMH works. Most of JMH is controlled by annotations, which are expressions in code that start with <code>@</code>. We&#39;ve already seen the <code>@tailrec</code> annotation. A method that we want to use a benchmark requires a <code>@Benchmark</code> annotation. Such methods must be declared in a class with no construtor arguments. Being a Java framework, JMH doesn&#39;t know about Scala&#39;s object literals. If the benchmark method relies on any fields or other values outside the method, these values must be annotated with <code>@State</code>. The easiest way to handle this is to annotate the entire class. That&#39;s enough to get started. You can find more from the resources above or by reading the benchmark code in this project.</p>
            <p class="nextPage"><a href="benchmark.html">Benchmarking→</a></p>
        </main>
        <footer>Creative Scala is copyright Noel Welsh</footer>
    </div>

    </div>
</body>

</html>