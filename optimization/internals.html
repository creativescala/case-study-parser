<!doctype html>
<html lang="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.19.0" />
    <title>Internal Optimizations</title>
    
    
    <meta name="description" content="docs" />
    
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="../creative-scala.css" />
    <script> /* for avoiding page load transitions */</script>
</head>

<body>
    <nav id="topbar"><p><a href="design.html">←</a></p>
<p><a href="https://creativescala.github.io/case-study-parser/index.html">Case Study: Parsing</a></p>
<p><a href="../context/index.html">→</a></p></nav>
    <nav id="sidebar">
        <ul class="nav-list">
          <li class="level1"><a href="../index.html">Case Study: Parsing</a></li>
          <li class="level1"><a href="../basics.html">The Simplest Parser</a></li>
          <li class="level1"><a href="../testing.html">Testing Parsers</a></li>
          <li class="level1"><a href="../type-classes/index.html">Designing Using Type Classes</a></li>
          <li class="level2"><a href="../type-classes/functor.html">Functor</a></li>
          <li class="level2"><a href="../type-classes/monoid.html">Monoid</a></li>
          <li class="level2"><a href="../type-classes/applicative.html">Applicative</a></li>
          <li class="level2"><a href="../type-classes/monad.html">Monad</a></li>
          <li class="level2"><a href="../type-classes/kleene.html">Kleene Star</a></li>
          <li class="level2"><a href="../type-classes/conclusions.html">Conclusions</a></li>
          <li class="level1"><a href="../expressions/index.html">Parsing Expressions</a></li>
          <li class="level2"><a href="../expressions/binary.html">Parsing Binary Operations</a></li>
          <li class="level2"><a href="../expressions/recursion.html">Recursive Expressions</a></li>
          <li class="level2"><a href="../expressions/json.html">Parsing JSON</a></li>
          <li class="level2"><a href="../expressions/conclusions.html">Conclusions</a></li>
          <li class="level1"><a href="index.html">Benchmarks and Optimization</a></li>
          <li class="level2"><a href="benchmark.html">Benchmarking</a></li>
          <li class="level2"><a href="design.html">Designing for Performance</a></li>
          <li class="level2 active"><a href="#">Internal Optimizations</a></li>
          <li class="level1"><a href="../context/index.html">Parsers in Context</a></li>
          <li class="level2"><a href="../context/evaluation.html">Controlling Order of Evaluation</a></li>
          <li class="level1"><a href="../references.html">References</a></li>
        </ul>
    </nav>

    <div id="content">
        <main class="content">
            <h1 id="internal-optimizations" class="title">Internal Optimizations</h1>
            <p>In this section we&#39;ll look at internal optimizations that are invisible to the end user.</p>
            
            <h3 id="memoization" class="section">Memoization</h3>
            <p>Our current implementation of <code>delay</code> re-evaluates the delayed <code>Parser</code> every time it is encountered in the interpreter. This is wasteful as the <code>Parser</code> will not change between evaluations. We can store the value after we first evaluate it, a technique known as <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>. </p>
            <p>Scala&#39;s <code>lazy val</code> makes memoization straightforward. A <code>lazy val</code> is like a <code>val</code> except the right-hand side expression, which produces the value, is not evaluated until the <code>lazy val</code> is first used. The value is then saved and used for subsequent uses. The following example shows these semantics. Note the <code>println</code> is not evaluated until the first use, but future uses do not re-evaluate the <code>println</code>.</p>
            <pre><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">a</span><span> = { 
  </span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;Evaluating&quot;</span><span>)
  </span><span class="number-literal">1</span><span>
}
</span><span class="identifier">a</span><span>
</span><span class="comment">// Evaluating
// res0: Int = 1
</span><span class="identifier">a</span><span>
</span><span class="comment">// res1: Int = 1</span></code></pre>
            <p>(Make sure you understand the difference between the behaviour of <code>val</code>, <code>lazy val</code>, and <code>def</code>. If you&#39;re unsure on the difference, replace <code>lazy val</code> with <code>val</code> and with <code>def</code> and see how the output changes.)</p>
            <p>With a <code>lazy val</code> we can change the reification of <code>delay</code>, which in my implmentation is a case class called <code>ParserDelay</code>, to memoize the delayed parser. I&#39;ve shown how to do this below, but try to do it yourself before reading my solution.</p>
            <pre><code class="nohighlight"><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">ParserDelay</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">parser</span><span>: () =&gt; </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]) </span><span class="keyword">extends</span><span> </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>] {
  </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">force</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="identifier">parser</span><span>()
}</span></code></pre>
            <p>Now we should verify this change actually improves performance. Parsing expressions, which we looked at in the <a href="../expressions/recursion.html">previous section</a>, depends on delayed parsers and therefore makes a good benchmark. Be careful when benchmarking this change. You may need to change how <code>orElse</code> is implemented in addition to <code>Parser.delay</code>.</p>
            <p>Below are the results from my experiments. I don&#39;t see any consistent improvement from memoization; the memoized and non-memoized parsers are within the error bounds of each other. The results are surprising to me; I was expecting to see more effect from memoization. I tried a lot of different implementations to try to find a consistent performance difference, but was unable to do so.</p>
            <pre><code>[info] Benchmark                                               Mode  Cnt       Score      Error  Units
[info] ExpressionBenchmark.exprParser                         thrpt   25   30904.951 ±  612.385  ops/s
[info] ExpressionBenchmark.exprMemoizedParser                 thrpt   25   31923.289 ±  520.764  ops/s
[info] ExpressionBenchmark.exprWhereMemoizedParser            thrpt   25  123323.837 ± 3973.923  ops/s
[info] ExpressionBenchmark.exprWhereParser                    thrpt   25  128436.999 ± 3552.719  ops/s
[info] ExpressionBenchmark.exprWhereAccumulateParser          thrpt   25  182851.316 ± 3105.287  ops/s
[info] ExpressionBenchmark.exprWhereAccumulateMemoizedParser  thrpt   25  183370.477 ± 8889.627  ops/s</code></pre>
            <p>A failing experiment is still a useful experiment. It shows that my model of program performance doesn&#39;t match reality, and I need to revise my model. In this case the issue is something relatively mundane. We&#39;re still avoiding some work with memoization, but the work is so trivial that it doesn&#39;t meaningfully effect performance. When we create a recursive parser, like the one below, we&#39;re creating a circular data structure. The when we evaluate the <code>delay</code> we&#39;re following a reference back into the data structure. The performance difference between evaluating a function to produce this reference, or just directly getting the reference, is very small.</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">term</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Expr</span><span>] =
  (</span><span class="identifier">number</span><span>, </span><span class="identifier">mul</span><span>, </span><span class="type-name">Parser</span><span>.</span><span class="identifier">delay</span><span>(</span><span class="identifier">term</span><span>))
    .</span><span class="identifier">mapN</span><span>((</span><span class="identifier">f</span><span>, </span><span class="identifier">_</span><span>, </span><span class="identifier">t</span><span>) =&gt; </span><span class="type-name">Expr</span><span>.</span><span class="identifier">literal</span><span>(</span><span class="identifier">f</span><span>) * </span><span class="identifier">t</span><span>)
    .</span><span class="identifier">orElse</span><span>(</span><span class="identifier">number</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Expr</span><span>.</span><span class="identifier">literal</span><span> </span><span class="identifier">_</span><span>))</span></code></pre>
            <p>In more complicated situtation we might want more detail about how the code runs inside the JVM. A good place to start is with a profiler such as <a href="https://visualvm.github.io/index.html">Visual VM</a>. This may not give enough detail, in which case we can look at the generated output code. <a href="https://www.beyondjava.net/show-assembly-code-generated-jvm">This blog post</a> goes into more detail on how this can be done.</p>
            
            <h3 id="rewriting" class="section">Rewriting</h3>
            <p>In many cases we can express the same functionality using  <code>charIn</code> or <code>charWhere</code>. This is a problem when it comes to reasoning about performance. We&#39;ve seen that <code>charWhere</code> can be much more efficient than <code>charIn</code>, but its not obvious to the user that this is the case. We&#39;d ideally like equivalent code to have roughly equivalent performance no matter how it&#39;s written, rather than requiring the developer to know obscure implementation specific rules.</p>
            <p>We can achieve this by rewriting <code>charIn</code> to <code>charWhere</code>. In fact we can do better, by rewriting any chain of <code>orElse</code> and <code>Parser.char</code> into <code>charWhere</code>. For example, if we see</p>
            <pre><code class="nohighlight"><span class="type-name">Parser</span><span>.</span><span class="identifier">char</span><span>(</span><span class="char-literal">&#39;a&#39;</span><span>).</span><span class="identifier">orElse</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">char</span><span>(</span><span class="char-literal">&#39;b&#39;</span><span>))</span></code></pre>
            <p>we can rewrite it to</p>
            <pre><code class="nohighlight"><span class="type-name">Parser</span><span>.</span><span class="identifier">charWhere</span><span>(</span><span class="identifier">x</span><span> =&gt; </span><span class="identifier">x</span><span> == </span><span class="char-literal">&#39;a&#39;</span><span> || </span><span class="identifier">x</span><span> == </span><span class="char-literal">&#39;b&#39;</span><span>)</span></code></pre>
            <p>This type of optimization, where we rewrite code into a functionally equivalent but more efficient alternative, is the core of what optimizing compilers do.</p>
            <p>I want to be able to benchmark this optimization against the current implementation, so I&#39;m going to implement it in a separate object in a separate file. Because we&#39;ve reified <code>Parser</code>, and hence it&#39;s represented as an algebraic data type, we can easily do this. </p>
            <p>My implementation of the optimization has three parts:</p>
            <ul>
              <li>given a <code>Parser</code>, I walk over the tree of elements looking for an <code>orElse</code>;</li>
              <li>once I find an <code>orElse</code> I see if it only contains <code>orElse</code> and <code>charIn</code>; and</li>
              <li>if so, I convert into an equivalent <code>charWhere</code>; otherwise I leave it alone.</li>
            </ul>
            <p>Have a go at implementing it yourself. It should use techniques you already know, <em>except</em> you&#39;re likely to run into one issue: the type system. Attempting to convince the type system that the rewrite is valid cannot be done with just what we have available. The issue is we are attempting to replace, at run-time, an <code>OrElse[A,B]</code> with a <code>CharWhere</code>, and the compiler doesn&#39;t know that <code>A</code> and <code>B</code> will both be <code>Char</code> and hence this is ok. We know because we check this is the case, but we cannot represent this check in a way the compiler understands. Remember types exist at compile-time and this is a run-time operation. We could transfer information from compile-time to run-time using so-called &quot;implicit evidence&quot; but doing so requires changing the interface which goes against the idea that this is a purely internal change. The solution is to throw in an <code>asInstanceOf</code> call, to tell the compiler &quot;I know you think this <code>Parser[Char]</code> is not the same as the <code>Parser[A]</code> you&#39;re looking for, but trust me&quot;. In general, you should <em>never</em> use this method. In almost all the cases I&#39;ve seen it&#39;s a sign of a bad design. It&#39;s justified here because we&#39;re switching levels. The type system ensures correct construction of the parsers at <em>compile-time</em>. We&#39;re rewriting them at <em>run-time</em>, and have done our own checks to ensure the rewrite is correct.</p>
            <p>If you struggle, my implementation is below. Once you have an implementation run some benchmarks. In my benchmarks, results of which are also below, this transformation results in code that is about 25 times faster!</p>
            <p>Here&#39;s the implementation:</p>
            <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parser</span><span>.</span><span class="type-name">Parser</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">object</span><span> </span><span class="type-name">Optimize</span><span> {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">orElseCharToCharWhere</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">parser</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>] = {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">collectCharIn</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">parser</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Option</span><span>[</span><span class="type-name">Set</span><span>[</span><span class="type-name">Char</span><span>]] =
      </span><span class="identifier">parser</span><span> </span><span class="keyword">match</span><span> {
        </span><span class="keyword">case</span><span> </span><span class="type-name">ParserChar</span><span>(</span><span class="identifier">value</span><span>) =&gt; </span><span class="type-name">Set</span><span>(</span><span class="identifier">value</span><span>).</span><span class="identifier">some</span><span>
        </span><span class="keyword">case</span><span> </span><span class="type-name">ParserOrElse</span><span>(</span><span class="identifier">left</span><span>, </span><span class="identifier">right</span><span>) =&gt;
          (</span><span class="identifier">collectCharIn</span><span>(</span><span class="identifier">left</span><span>), </span><span class="identifier">collectCharIn</span><span>(</span><span class="identifier">right</span><span>)).</span><span class="identifier">mapN</span><span>((</span><span class="identifier">l</span><span>, </span><span class="identifier">r</span><span>) =&gt; </span><span class="identifier">l</span><span> ++ </span><span class="identifier">r</span><span>)
        </span><span class="keyword">case</span><span> </span><span class="identifier">_</span><span> =&gt; </span><span class="identifier">none</span><span>[</span><span class="type-name">Set</span><span>[</span><span class="type-name">Char</span><span>]]
      }

    </span><span class="keyword">def</span><span> </span><span class="declaration-name">toCharWhere</span><span>(</span><span class="identifier">chars</span><span>: </span><span class="type-name">Set</span><span>[</span><span class="type-name">Char</span><span>]): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Char</span><span>] =
      </span><span class="type-name">Parser</span><span>.</span><span class="identifier">charWhere</span><span>(</span><span class="identifier">char</span><span> =&gt; </span><span class="identifier">chars</span><span>.</span><span class="identifier">contains</span><span>(</span><span class="identifier">char</span><span>))

    </span><span class="identifier">parser</span><span> </span><span class="keyword">match</span><span> {
      </span><span class="keyword">case</span><span> </span><span class="identifier">p</span><span>: </span><span class="type-name">ParserOrElse</span><span>[</span><span class="identifier">a</span><span>] =&gt;
        </span><span class="keyword">val</span><span> </span><span class="identifier">chars</span><span> = </span><span class="identifier">collectCharIn</span><span>(</span><span class="identifier">p</span><span>)
        </span><span class="identifier">chars</span><span>
          .</span><span class="identifier">map</span><span>(</span><span class="identifier">chars</span><span> =&gt; </span><span class="identifier">toCharWhere</span><span>(</span><span class="identifier">chars</span><span>).</span><span class="identifier">asInstanceOf</span><span>[</span><span class="type-name">Parser</span><span>[</span><span class="identifier">a</span><span>]])
          .</span><span class="identifier">getOrElse</span><span>(</span><span class="identifier">p</span><span>)
      </span><span class="keyword">case</span><span> </span><span class="type-name">ParserMap</span><span>(</span><span class="identifier">source</span><span>, </span><span class="identifier">f</span><span>) =&gt; </span><span class="type-name">ParserMap</span><span>(</span><span class="identifier">orElseCharToCharWhere</span><span>(</span><span class="identifier">source</span><span>), </span><span class="identifier">f</span><span>)
      </span><span class="keyword">case</span><span> </span><span class="type-name">ParserRepeatBetween</span><span>(</span><span class="identifier">source</span><span>, </span><span class="identifier">min</span><span>, </span><span class="identifier">max</span><span>, </span><span class="identifier">monoid</span><span>) =&gt;
        </span><span class="type-name">ParserRepeatBetween</span><span>(</span><span class="identifier">orElseCharToCharWhere</span><span>(</span><span class="identifier">source</span><span>), </span><span class="identifier">min</span><span>, </span><span class="identifier">max</span><span>, </span><span class="identifier">monoid</span><span>)
      </span><span class="keyword">case</span><span> </span><span class="type-name">ParserRepeat</span><span>(</span><span class="identifier">source</span><span>, </span><span class="identifier">monoid</span><span>) =&gt;
        </span><span class="type-name">ParserRepeat</span><span>(</span><span class="identifier">orElseCharToCharWhere</span><span>(</span><span class="identifier">source</span><span>), </span><span class="identifier">monoid</span><span>)
      </span><span class="keyword">case</span><span> </span><span class="type-name">ParserRepeatAccumulator</span><span>(</span><span class="identifier">source</span><span>, </span><span class="identifier">min</span><span>, </span><span class="identifier">accumulator</span><span>) =&gt;
        </span><span class="type-name">ParserRepeatAccumulator</span><span>(</span><span class="identifier">orElseCharToCharWhere</span><span>(</span><span class="identifier">source</span><span>), </span><span class="identifier">min</span><span>, </span><span class="identifier">accumulator</span><span>)
      </span><span class="keyword">case</span><span> </span><span class="type-name">ParserProduct</span><span>(</span><span class="identifier">left</span><span>, </span><span class="identifier">right</span><span>) =&gt;
        </span><span class="type-name">ParserProduct</span><span>(</span><span class="identifier">orElseCharToCharWhere</span><span>(</span><span class="identifier">left</span><span>), </span><span class="identifier">orElseCharToCharWhere</span><span>(</span><span class="identifier">right</span><span>))
      </span><span class="keyword">case</span><span> </span><span class="type-name">ParserAnd</span><span>(</span><span class="identifier">left</span><span>, </span><span class="identifier">right</span><span>, </span><span class="identifier">semigroup</span><span>) =&gt;
        </span><span class="type-name">ParserAnd</span><span>(
          </span><span class="identifier">orElseCharToCharWhere</span><span>(</span><span class="identifier">left</span><span>),
          </span><span class="identifier">orElseCharToCharWhere</span><span>(</span><span class="identifier">right</span><span>),
          </span><span class="identifier">semigroup</span><span>
        )
      </span><span class="keyword">case</span><span> </span><span class="type-name">ParserFlatMap</span><span>(</span><span class="identifier">source</span><span>, </span><span class="identifier">f</span><span>) =&gt;
        </span><span class="type-name">ParserFlatMap</span><span>(</span><span class="identifier">orElseCharToCharWhere</span><span>(</span><span class="identifier">source</span><span>), </span><span class="identifier">f</span><span>)
      </span><span class="keyword">case</span><span> </span><span class="identifier">other</span><span> =&gt; </span><span class="identifier">other</span><span>
    }
  }
}</span></code></pre>
            <p>Here are the benchmark results:</p>
            <pre><code>[info] Benchmark                                          Mode  Cnt        Score       Error  Units
[info] ToCharWhereBenchmark.parser                       thrpt   25   104026.788 ±   565.152  ops/s
[info] ToCharWhereBenchmark.parserOrElseCharToCharWhere  thrpt   25  2565950.528 ± 54878.768  ops/s</code></pre>
            <p>There are many more rewrites you could attempt to improve performance. For example, you could implement <em>map-fusion</em>, transforming <code>aParser.map(f).map(g)</code> into <code>aParser.map(f.andThen(g))</code>.</p>
            <p class="nextPage"><a href="../context/index.html">Parsers in Context→</a></p>
        </main>
        <footer>Creative Scala is copyright Noel Welsh</footer>
    </div>

    </div>
</body>

</html>