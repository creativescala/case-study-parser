<!doctype html>
<html lang="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.19.0" />
    <title>Designing Parsers</title>
    
    
    <meta name="description" content="docs" />
    
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="creative-scala.css" />
    <script> /* for avoiding page load transitions */</script>
</head>

<body>
    <nav id="topbar"><p><a href="testing.html">←</a></p>
<p><a href="../">Case Study: Parsing</a></p>
<p><a href="implementation.html">→</a></p></nav>
    <nav id="sidebar">
        <ul class="nav-list">
          <li class="level1"><a href="index.html">Case Study: Parsing</a></li>
          <li class="level1"><a href="basics.html">The Simplest Parser</a></li>
          <li class="level1"><a href="testing.html">Testing Parsers</a></li>
          <li class="level1 active"><a href="#">Designing Parsers</a></li>
          <li class="level1"><a href="implementation.html">Implementing Parsers</a></li>
          <li class="level1"><a href="references.html">References</a></li>
        </ul>
    </nav>

    <div id="content">
        <main class="content">
            <h1 id="designing-parsers" class="title">Designing Parsers</h1>
            
            <h3 id="functor" class="section">Functor</h3>
            <p>Functor requires only a <code>map</code> method, which for a <code>Parser</code> will have the type signature</p>
            <pre><code class="nohighlight"><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>].</span><span class="identifier">map</span><span>[</span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">B</span><span>]</span></code></pre>
            <p>This means that we can take an existing parser that produces output of one type, and turn it into a parser that produces an output of some other type. Is this useful? It turns out to be very useful. Right now we can only create a <code>Parser[String]</code>. Adding <code>map</code> means that we can turn that <code>String</code> into any other type we care about, like an <code>Int</code> for example.</p>
            
            <h3 id="applicative" class="section">Applicative</h3>
            <p>Applicative defines <code>ap</code> and <code>pure</code>, but remember that in Scala we mostly interact with the <code>product</code> method defined on <code>Semigroupal</code> via <code>mapN</code>. So we&#39;ll consider <code>product</code> and <code>pure</code>, which together with <code>map</code> are sufficient to create an applicative.</p>
            <pre><code class="nohighlight"><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>].</span><span class="identifier">product</span><span>[</span><span class="type-name">B</span><span>](</span><span class="identifier">that</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="type-name">Parser</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>)]
</span><span class="identifier">pure</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">value</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
            <p>Can you think of a use for these methods? Give this a bit of time before reading on.</p>
            <p>Both methods are useful, though <code>product</code> is the more useful of the two. <code>Product</code> means we can combine in sequence two or more parsers that produce different types. We started with an example of parsing text fields into the following data structure:</p>
            <pre><code class="nohighlight"><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Album</span><span>(</span><span class="identifier">artist</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">name</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">year</span><span>: </span><span class="type-name">Int</span><span>)</span></code></pre>
            <p>If we have a <code>Parser[String]</code> and a <code>Parser[Int]</code> we create an <code>Album</code> with a combination of <code>product</code> and <code>map</code>.</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">stringParser</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] = ???
</span><span class="keyword">val</span><span> </span><span class="identifier">intParser</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Int</span><span>] = ???

</span><span class="identifier">stringParser</span><span>
  .</span><span class="identifier">product</span><span>(</span><span class="identifier">stringParser</span><span>)
  .</span><span class="identifier">product</span><span>(</span><span class="identifier">intParser</span><span>)
  .</span><span class="identifier">map</span><span>{ </span><span class="keyword">case</span><span> ((</span><span class="identifier">a</span><span>, </span><span class="identifier">n</span><span>), </span><span class="identifier">y</span><span>) =&gt; </span><span class="type-name">Album</span><span>(</span><span class="identifier">a</span><span>, </span><span class="identifier">n</span><span>, </span><span class="identifier">y</span><span>) }</span></code></pre>
            <p>We can more simply write this using <code>mapN</code>: </p>
            <pre><code class="nohighlight"><span>(</span><span class="identifier">stringParser</span><span>, </span><span class="identifier">stringParser</span><span>, </span><span class="identifier">intParser</span><span>)
  .</span><span class="identifier">mapN</span><span>((</span><span class="identifier">a</span><span>, </span><span class="identifier">n</span><span>, </span><span class="identifier">y</span><span>) =&gt; </span><span class="type-name">Album</span><span>(</span><span class="identifier">a</span><span>, </span><span class="identifier">n</span><span>, </span><span class="identifier">y</span><span>))</span></code></pre>
            <p><code>Pure</code> is less useful, but is still nice to have. It constructs a <code>Parser</code> that always produces the given value and ignores it&#39;s input. It&#39;s sometimes useful when we know that if we parse some input then some other output is implied. We can create this other output with <code>pure</code>. (No example here because I can&#39;t think of one right now!)</p>
            
            <h3 id="monad" class="section">Monad</h3>
            <p>We&#39;ve dealt with applicative. What about monad? This means a method</p>
            <pre><code class="nohighlight"><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>].</span><span class="identifier">flatMap</span><span>[</span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">Parser</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">B</span><span>]</span></code></pre>
            <p>What does this mean in the context of parsing? Can you see uses for <code>flatMap</code>? Once again, spend some time on this before reading on.</p>
            <p><code>FlatMap</code>allows us to switch to a parser based on the output of another parser. This is done by the function <code>f</code> passed to <code>flatMap</code>. It takes the output of the first parser, and can use that output to choose a parser to parse the rest of the input. For example, we could use <code>flatMap</code> to parse a file where one field tells us the format of the next field. A file like</p>
            <pre><code>number: 100
string: hello</code></pre>
            <p>could be parsed with</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">fieldParser</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] = ??? </span><span class="comment">// parses &lt;type&gt;: and returns &lt;type&gt;
</span><span class="keyword">val</span><span> </span><span class="identifier">intParser</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Int</span><span>] = ???
</span><span class="keyword">val</span><span> </span><span class="identifier">stringParser</span><span> = </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>] = ???

</span><span class="identifier">fieldParser</span><span>.</span><span class="identifier">flatMap</span><span>(</span><span class="identifier">result</span><span> =&gt;
  </span><span class="identifier">result</span><span> </span><span class="keyword">match</span><span> {
    </span><span class="keyword">case</span><span> </span><span class="string-literal">&quot;number&quot;</span><span> =&gt; </span><span class="identifier">intParser</span><span>
    </span><span class="keyword">case</span><span> </span><span class="string-literal">&quot;string&quot;</span><span> =&gt; </span><span class="identifier">stringParser</span><span>
  }
)</span></code></pre>
            <p>Adding <code>flatMap</code> has some drawbacks, which we&#39;ll see later on, but for now we&#39;ll add it in.</p>
            
            <h3 id="monoid" class="section">Monoid</h3>
            <p>Finally, let&#39;s consider our last type class, monoid. Remember that a monid requires two things:</p>
            <ol class="arabic">
              <li>a combining method; and</li>
              <li>an identity.</li>
            </ol>
            <p>In the context of our <code>Parser</code> type, the combine method would have type</p>
            <pre><code class="nohighlight"><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>].</span><span class="identifier">combine</span><span>(</span><span class="identifier">that</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
            <p>and the identity is an element of type <code>Parser[A]</code>.</p>
            <p>Can you think of applications of this type of operation for a parser? It may help to think of other monoids, such as those defined on sets and booleans, and consider how they would translate to a parser. If you can come up with a meaningful combine, what is it&#39;s identity?</p>
            <p>Spend some time thinking about this before reading on.</p>
            <p>Monoid is interesting because there at least two choices that make sense for a parser:</p>
            <ol class="arabic">
              <li>
                <p>The combine operation chooses between two parsers, known as alternation. If the first doesn&#39;t successfully parse the input we try again with the second input. This is the parser equivalent of the logical or operation, and the union of sets. The identity is the parser that always fails, regardless of it&#39;s input.</p>
              </li>
              <li>
                <p>The combine operation combines the results of two parsers. We parse the input with the first parser, parse the remaining input with the second parser, and then combine the output of both parsers if they were both successful. This requires we have a monoid for <code>A</code> to combine the output. This is the equivalent of the logical and, and the intersection of sets. The identity is the parser that always succeeds, producing the identity element for <code>A</code>.</p>
              </li>
            </ol>
            <p>The first variant of combine, choosing between parsers, is essential. The second is useful but not so important. We have enough work already so we&#39;ll skip it for now.</p>
            <p>As we have two useful monoids for parsers, when we come to implement them we should define methods directly on <code>Parser</code> rather than implementing them via a type class. Why? Because type classes work best when there is one canonical implementation for a given type. Switching between implementations requires us to explicitly pass the type class instance, or otherwise bring it into scope, which defeats much of the point of type classes. </p>
            <p>Alternation is conventionally known as <code>orElse</code> in Scala, and uses a call-by-name parameter. </p>
            <pre><code class="nohighlight"><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>].</span><span class="identifier">orElse</span><span>(</span><span class="identifier">that</span><span>: =&gt; </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
            <p>The call-by-name parameter will turn out to be essential for parsers, and differs for the definition of <code>combine</code> on <code>Monoid</code>, which is another good reason to implement the method directly.</p>
            
            <h3 id="our-final-initial-interface" class="section">Our Final Initial Interface</h3>
            <p>At this point we&#39;ve developed quite a rich interface:</p>
            <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">map</span><span>[</span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">B</span><span>]
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">product</span><span>[</span><span class="type-name">B</span><span>](</span><span class="identifier">that</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="type-name">Parser</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>)]
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">flatMap</span><span>[</span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">Parser</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">B</span><span>]
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">orElse</span><span>(</span><span class="identifier">that</span><span>: =&gt; </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">parse</span><span>(</span><span class="identifier">input</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Result</span><span>[</span><span class="type-name">A</span><span>]
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Parser</span><span> {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">string</span><span>(</span><span class="identifier">value</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">String</span><span>]
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">pure</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">value</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">fail</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]
}</span></code></pre>
            <p>There are more methods we&#39;ll eventually need, but this is more than enough to get us started. Let&#39;s move on to implementation and get a complete system working.</p>
            <p class="nextPage"><a href="implementation.html">Implementing Parsers→</a></p>
        </main>
        <footer>Creative Scala is copyright Noel Welsh</footer>
    </div>

    </div>
</body>

</html>