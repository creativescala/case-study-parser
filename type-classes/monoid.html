<!doctype html>
<html lang="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.19.0" />
    <title>Monoid</title>
    
    
    <meta name="description" content="docs" />
    
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="../creative-scala.css" />
    <script> /* for avoiding page load transitions */</script>
</head>

<body>
    <nav id="topbar"><p><a href="functor.html">←</a></p>
<p><a href="../../">Case Study: Parsing</a></p>
<p><a href="applicative.html">→</a></p></nav>
    <nav id="sidebar">
        <ul class="nav-list">
          <li class="level1"><a href="../index.html">Case Study: Parsing</a></li>
          <li class="level1"><a href="../basics.html">The Simplest Parser</a></li>
          <li class="level1"><a href="../testing.html">Testing Parsers</a></li>
          <li class="level1"><a href="index.html">Designing Using Type Classes</a></li>
          <li class="level2"><a href="functor.html">Functor</a></li>
          <li class="level2 active"><a href="#">Monoid</a></li>
          <li class="level2"><a href="applicative.html">Applicative</a></li>
          <li class="level2"><a href="monad.html">Monad</a></li>
          <li class="level2"><a href="kleene.html">Kleene Star</a></li>
          <li class="level2"><a href="conclusions.html">Conclusions</a></li>
          <li class="level1"><a href="../expressions/index.html">Parsing Expressions</a></li>
          <li class="level2"><a href="../expressions/binary.html">Parsing Binary Operations</a></li>
          <li class="level2"><a href="../expressions/recursion.html">Recursive Expressions</a></li>
          <li class="level1"><a href="../references.html">References</a></li>
        </ul>
    </nav>

    <div id="content">
        <main class="content">
            <h1 id="monoid" class="title">Monoid</h1>
            <p>As our next type class, let&#39;s consider our last type class, monoid. Remember that a monid requires two things:</p>
            <ol class="arabic">
              <li>a combining method; and</li>
              <li>an identity.</li>
            </ol>
            <p>In the context of our <code>Parser</code> type, the combine method would have type</p>
            <pre><code class="nohighlight"><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>].</span><span class="identifier">combine</span><span>(</span><span class="identifier">that</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
            <p>and the identity is an element of type <code>Parser[A]</code>.</p>
            <p>Can you think of applications of this type of operation for a parser? It may help to think of other monoids, such as those defined on sets and booleans, and consider how they would translate to a parser. If you can come up with a meaningful combine, what is it&#39;s identity?</p>
            <p>Spend some time thinking about this before reading on.</p>
            <p>Monoid is interesting because there at least two choices that make sense for a parser:</p>
            <ol class="arabic">
              <li>
                <p>The combine operation chooses between two parsers, known as alternation. If the first doesn&#39;t successfully parse the input we try again with the second input. This is the parser equivalent of the logical or operation, and the union of sets. The identity is the parser that always fails, regardless of it&#39;s input.</p>
              </li>
              <li>
                <p>The combine operation combines the results of two parsers. We parse the input with the first parser, parse the remaining input with the second parser, and then combine the output of both parsers if they were both successful. This requires we have a semigroup for <code>A</code> to combine the output. This is the equivalent of the logical and, and the intersection of sets. The identity is the parser that always succeeds, producing the identity element for <code>A</code>.</p>
              </li>
            </ol>
            <p>The first variant of combine, choosing between parsers, is essential. The second is useful but not so important. We have enough work already so we&#39;ll skip it for now.</p>
            <p>Alternation is conventionally known as <code>orElse</code> in Scala, and uses a call-by-name parameter. </p>
            <pre><code class="nohighlight"><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>].</span><span class="identifier">orElse</span><span>(</span><span class="identifier">that</span><span>: =&gt; </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
            <p>The call-by-name parameter differs from the definition of <code>combine</code> on <code>Monoid</code>, but will turn out to be essential for parsers.</p>
            <p>With alternation we can write the following <code>Parser</code> to check for any digit.</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">digit</span><span>: </span><span class="type-name">Parser</span><span>[</span><span class="type-name">Int</span><span>] =
  </span><span class="type-name">List</span><span>(</span><span class="number-literal">0</span><span>, </span><span class="number-literal">1</span><span>, </span><span class="number-literal">2</span><span>, </span><span class="number-literal">3</span><span>, </span><span class="number-literal">4</span><span>, </span><span class="number-literal">5</span><span>, </span><span class="number-literal">6</span><span>, </span><span class="number-literal">7</span><span>, </span><span class="number-literal">8</span><span>, </span><span class="number-literal">9</span><span>)
    .</span><span class="identifier">foldLeft</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">fail</span><span>[</span><span class="type-name">Int</span><span>]){ (</span><span class="identifier">accum</span><span>, </span><span class="identifier">digit</span><span>) =&gt;
      </span><span class="identifier">accum</span><span>.</span><span class="identifier">orElse</span><span>(</span><span class="type-name">Parser</span><span>.</span><span class="identifier">string</span><span>(</span><span class="identifier">digit</span><span>.</span><span class="identifier">toString</span><span>).</span><span class="identifier">as</span><span>(</span><span class="identifier">digit</span><span>)) 
    }</span></code></pre>
            <p>Note that <code>as</code> is a method we get by implementing the <code>Functor</code> instance for <code>Parser</code>.</p>
            <p>Now it&#39;s over to you to implement the <code>orElse</code>, the identity, which I called <code>fail</code> in the example above, and the tests. Remember to follow the reification pattern and you should find this reasonably straightforward.</p>
            <p class="nextPage"><a href="applicative.html">Applicative→</a></p>
        </main>
        <footer>Creative Scala is copyright Noel Welsh</footer>
    </div>

    </div>
</body>

</html>