<!doctype html>
<html lang="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.19.0" />
    <title>Controlling Order of Evaluation</title>
    
    
    <meta name="description" content="docs" />
    
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="../creative-scala.css" />
    <script> /* for avoiding page load transitions */</script>
</head>

<body>
    <nav id="topbar"><p><a href="index.html">←</a></p>
<p><a href="../../">Case Study: Parsing</a></p>
<p><a href="../references.html">→</a></p></nav>
    <nav id="sidebar">
        <ul class="nav-list">
          <li class="level1"><a href="../index.html">Case Study: Parsing</a></li>
          <li class="level1"><a href="../basics.html">The Simplest Parser</a></li>
          <li class="level1"><a href="../testing.html">Testing Parsers</a></li>
          <li class="level1"><a href="../type-classes/index.html">Designing Using Type Classes</a></li>
          <li class="level2"><a href="../type-classes/functor.html">Functor</a></li>
          <li class="level2"><a href="../type-classes/monoid.html">Monoid</a></li>
          <li class="level2"><a href="../type-classes/applicative.html">Applicative</a></li>
          <li class="level2"><a href="../type-classes/monad.html">Monad</a></li>
          <li class="level2"><a href="../type-classes/kleene.html">Kleene Star</a></li>
          <li class="level2"><a href="../type-classes/conclusions.html">Conclusions</a></li>
          <li class="level1"><a href="../expressions/index.html">Parsing Expressions</a></li>
          <li class="level2"><a href="../expressions/binary.html">Parsing Binary Operations</a></li>
          <li class="level2"><a href="../expressions/recursion.html">Recursive Expressions</a></li>
          <li class="level2"><a href="../expressions/json.html">Parsing JSON</a></li>
          <li class="level2"><a href="../expressions/conclusions.html">Conclusions</a></li>
          <li class="level1"><a href="../optimization/index.html">Benchmarks and Optimization</a></li>
          <li class="level2"><a href="../optimization/benchmark.html">Benchmarking</a></li>
          <li class="level2"><a href="../optimization/design.html">Designing for Performance</a></li>
          <li class="level2"><a href="../optimization/internals.html">Internal Optimizations</a></li>
          <li class="level1"><a href="index.html">Parsers in Context</a></li>
          <li class="level2 active"><a href="#">Controlling Order of Evaluation</a></li>
          <li class="level1"><a href="../references.html">References</a></li>
        </ul>
    </nav>

    <div id="content">
        <main class="content">
            <h1 id="controlling-order-of-evaluation" class="title">Controlling Order of Evaluation</h1>
            <p>The technique we used to implement recursive parsers is a general technique for handling any potentially unbounded recursive structure: delay building the structure until it is needed.</p>
            <p>In this section we will:</p>
            <ul>
              <li>touch on a classic application of this idea;</li>
              <li>discuss how it relates to order of evaluation;</li>
              <li>discuss how it relates to ideas of computation vs data; and</li>
              <li>provide some references where you can learn more.</li>
            </ul>
            
            <h3 id="infinite-lists" class="section">Infinite Lists</h3>
            <p>Building infinite lists is a classic application of delaying evaluation. We already know finite lists. A list of <code>A</code> is:</p>
            <ul>
              <li>the empty list; or</li>
              <li>a pair with a head of type <code>A</code> and a tail that is a list of <code>A</code>.</li>
            </ul>
            <p>This is an algebraic data type, and we know systematic techniques to implmement it and write methods using it.</p>
            <p>We can change this to an infinite list by delaying the tail. We&#39;ll first define a class to hold delayed values. This class has a single method to evaluate the delayed values, known as forcing them.</p>
            <pre><code class="nohighlight"><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Delay</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">delayed</span><span>: () =&gt; </span><span class="type-name">A</span><span>) {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">force</span><span>: </span><span class="type-name">A</span><span> = </span><span class="identifier">delayed</span><span>()
}</span></code></pre>
            <p>Now we can define an infinite list.</p>
            <pre><code class="nohighlight"><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">A</span><span>]
</span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Empty</span><span>[</span><span class="type-name">A</span><span>]() </span><span class="keyword">extends</span><span> </span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">A</span><span>]
</span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Pair</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">head</span><span>: </span><span class="type-name">A</span><span>, </span><span class="identifier">tail</span><span>: </span><span class="type-name">Delay</span><span>[</span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">A</span><span>]]) </span><span class="keyword">extends</span><span> </span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
            <p>As an example we can create an infinite list of ones as follows.</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">ones</span><span>: </span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="type-name">Pair</span><span>(</span><span class="number-literal">1</span><span>, </span><span class="type-name">Delay</span><span>(() =&gt; </span><span class="identifier">ones</span><span>))</span></code></pre>
            <p>How do we know this is really a lists of ones? Let&#39;s redefine our infinite list with some useful methods.</p>
            <pre><code class="nohighlight"><span class="comment">// This construction allows us to call the apply method on the companion object
// (which has a call-by-name parameter) making it easier to construct delayed
// values.
</span><span class="keyword">class</span><span> </span><span class="type-name">Delay</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">delayed</span><span>: () =&gt; </span><span class="type-name">A</span><span>) {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">force</span><span>: </span><span class="type-name">A</span><span> = </span><span class="identifier">delayed</span><span>()
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Delay</span><span> {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">value</span><span>: =&gt; </span><span class="type-name">A</span><span>): </span><span class="type-name">Delay</span><span>[</span><span class="type-name">A</span><span>] =
    </span><span class="keyword">new</span><span> </span><span class="type-name">Delay</span><span>(() =&gt; </span><span class="identifier">value</span><span>)
}

</span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">A</span><span>] {
  </span><span class="keyword">import</span><span> </span><span class="type-name">InfiniteList</span><span>.</span><span class="identifier">_</span><span>
  </span><span class="keyword">def</span><span> ::(</span><span class="identifier">value</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">A</span><span>] = 
    </span><span class="type-name">Pair</span><span>(</span><span class="identifier">value</span><span>, </span><span class="type-name">Delay</span><span>(</span><span class="keyword">this</span><span>))

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">map</span><span>[</span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>): </span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">B</span><span>] =
    </span><span class="keyword">this</span><span> </span><span class="keyword">match</span><span> {
      </span><span class="keyword">case</span><span> </span><span class="type-name">Empty</span><span>()    =&gt; </span><span class="type-name">Empty</span><span>()
      </span><span class="keyword">case</span><span> </span><span class="type-name">Pair</span><span>(</span><span class="identifier">h</span><span>, </span><span class="identifier">t</span><span>) =&gt; </span><span class="type-name">Pair</span><span>(</span><span class="identifier">f</span><span>(</span><span class="identifier">h</span><span>), </span><span class="type-name">Delay</span><span>(</span><span class="identifier">t</span><span>.</span><span class="identifier">force</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">f</span><span>)))
    }
    
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">zip</span><span>[</span><span class="type-name">B</span><span>](</span><span class="identifier">that</span><span>: </span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="type-name">InfiniteList</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>)] =
    (</span><span class="keyword">this</span><span>, </span><span class="identifier">that</span><span>) </span><span class="keyword">match</span><span> {
      </span><span class="keyword">case</span><span> (</span><span class="type-name">Pair</span><span>(</span><span class="identifier">h1</span><span>, </span><span class="identifier">t1</span><span>), </span><span class="type-name">Pair</span><span>(</span><span class="identifier">h2</span><span>, </span><span class="identifier">t2</span><span>)) =&gt;
        </span><span class="type-name">Pair</span><span>((</span><span class="identifier">h1</span><span>, </span><span class="identifier">h2</span><span>), </span><span class="type-name">Delay</span><span>(</span><span class="identifier">t1</span><span>.</span><span class="identifier">force</span><span>.</span><span class="identifier">zip</span><span>(</span><span class="identifier">t2</span><span>.</span><span class="identifier">force</span><span>)))
      </span><span class="keyword">case</span><span> </span><span class="identifier">_</span><span> =&gt; </span><span class="type-name">Empty</span><span>()
    }
    
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">take</span><span>(</span><span class="identifier">count</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>] =
    </span><span class="keyword">if</span><span>(</span><span class="identifier">count</span><span> &lt;= </span><span class="number-literal">0</span><span>) </span><span class="type-name">List</span><span>.</span><span class="identifier">empty</span><span>
    </span><span class="keyword">else</span><span> {
      </span><span class="keyword">this</span><span> </span><span class="keyword">match</span><span> {
        </span><span class="keyword">case</span><span> </span><span class="type-name">Empty</span><span>()    =&gt; </span><span class="type-name">List</span><span>.</span><span class="identifier">empty</span><span>
        </span><span class="keyword">case</span><span> </span><span class="type-name">Pair</span><span>(</span><span class="identifier">h</span><span>, </span><span class="identifier">t</span><span>) =&gt; </span><span class="identifier">h</span><span> :: </span><span class="identifier">t</span><span>.</span><span class="identifier">force</span><span>.</span><span class="identifier">take</span><span>(</span><span class="identifier">count</span><span> - </span><span class="number-literal">1</span><span>)
      }
    }
}
</span><span class="keyword">object</span><span> </span><span class="type-name">InfiniteList</span><span> {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">head</span><span>: </span><span class="type-name">A</span><span>, </span><span class="identifier">tail</span><span>: </span><span class="type-name">Delay</span><span>[</span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">A</span><span>]]): </span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">A</span><span>] =
    </span><span class="type-name">Pair</span><span>(</span><span class="identifier">head</span><span>, </span><span class="identifier">tail</span><span>)

  </span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Empty</span><span>[</span><span class="type-name">A</span><span>]() </span><span class="keyword">extends</span><span> </span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">A</span><span>]
  </span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Pair</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">head</span><span>: </span><span class="type-name">A</span><span>, </span><span class="identifier">tail</span><span>: </span><span class="type-name">Delay</span><span>[</span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">A</span><span>]]) </span><span class="keyword">extends</span><span> </span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">A</span><span>]
}</span></code></pre>
            <p>Now we can do some fun things. First let&#39;s see that a finite portion of the infinite list of ones really is all ones.</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">ones</span><span>: </span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="type-name">InfiniteList</span><span>(</span><span class="number-literal">1</span><span>, </span><span class="type-name">Delay</span><span>(</span><span class="identifier">ones</span><span>))</span></code></pre>
            <pre><code class="nohighlight"><span class="identifier">ones</span><span>.</span><span class="identifier">take</span><span>(</span><span class="number-literal">5</span><span>)
</span><span class="comment">// res2: List[Int] = List(1, 1, 1, 1, 1)</span></code></pre>
            <p>It seems that our definition has worked.</p>
            <p>We can <code>map</code> our infinite list, and see that a finite portion is transformed as we expect.</p>
            <pre><code class="nohighlight"><span class="identifier">ones</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">_</span><span> + </span><span class="number-literal">2</span><span>).</span><span class="identifier">take</span><span>(</span><span class="number-literal">5</span><span>)
</span><span class="comment">// res3: List[Int] = List(3, 3, 3, 3, 3)</span></code></pre>
            <p>Finally, let&#39;s define the infinite list of natural numbers using only <code>ones</code> defined above.</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">naturals</span><span>: </span><span class="type-name">InfiniteList</span><span>[</span><span class="type-name">Int</span><span>] = 
  </span><span class="type-name">InfiniteList</span><span>(</span><span class="number-literal">1</span><span>, </span><span class="type-name">Delay</span><span>(</span><span class="identifier">ones</span><span>.</span><span class="identifier">zip</span><span>(</span><span class="identifier">naturals</span><span>).</span><span class="identifier">map</span><span>{ </span><span class="keyword">case</span><span> (</span><span class="identifier">a</span><span>, </span><span class="identifier">b</span><span>) =&gt; </span><span class="identifier">a</span><span> + </span><span class="identifier">b</span><span> }))</span></code></pre>
            <pre><code class="nohighlight"><span class="identifier">naturals</span><span>.</span><span class="identifier">take</span><span>(</span><span class="number-literal">5</span><span>)
</span><span class="comment">// res4: List[Int] = List(1, 2, 3, 4, 5)</span></code></pre>
            <p>I suggest making sure you&#39;re comfortable with <code>naturals</code> before reading on.</p>
            
            <h3 id="order-of-evaluation" class="section">Order of Evaluation</h3>
            <p>We&#39;ve seen how we can implement our <code>InfiniteList</code> using call-by-name parameters and further delaying evaluation using a no-argument function. Every time we need the delayed value, we evaluate the no-argument function. This general technique is known as call-by-name evaluation. (Note the subtle difference: this is call-by-name <em>evaluation</em>, which is more general than call-by-name <em>parameters</em>.)</p>
            <p>Call-by-name evaluation is not the only possibility. We could evaluate the delayed value the first time it is referred to, and store the result for future use. If we evaluate the delayed value again we just use the stored value, and so avoid repeating the work at the cost of using a bit more memory. This is known as call-by-value or lazy evaluation.</p>
            <p>Call-by-value (also known as eager evaluation) is the default in Scala and has no delayed values.</p>
            
            <h3 id="computation-and-data" class="section">Computation and Data</h3>
            <p>One way of looking at call-by-name versus call-by-value is to consider that we can represent data instead by the program that generates that data or vice versa. This perspective is useful in many different contexts. For example, a cache uses data to avoid computation. Compression uses a program (the decompression algorithm) to avoid data. These ideas lead to <a href="https://en.wikipedia.org/wiki/Algorithmic_information_theory">algorithmic information theory</a> and <a href="https://en.wikipedia.org/wiki/Kolmogorov_complexity">Kolmogorov complexity</a>.</p>
            <p>A different perspective comes from programming language theory, which distinguishes data from codata, and recursion from corecursion. Data is finite, while codata is infinite. <code>InfiniteList</code> is an example of codata. We have already know lots about data. For algebraic data we&#39;ve see that, for example, structural recursion allows us to easily manipulate and transform it. There are similar patterns of corecursion for codata, but these techniques are much less well known.</p>
            
            <h3 id="further-reading" class="section">Further Reading</h3>
            <p>I first learned about infinite lists from <a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-24.html#%_sec_3.5">SICP</a>. SICP is a classic, but it is a long book, leans heavily on electrical engineering and mathematical examples, and is rather old at this point. I read SICP at exactly the right time in my life (I had just graduated with a computer engineering degree and I had a regular train ride on which to read it) and it blew my mind. However it&#39;s not for everyone.</p>
            <p><a href="https://www.plai.org/">PLAI</a> covers much of the important bits of SICP in a more modern form, and contains no diversions into electrical engineering.</p>
            <p>The <code>InfiniteList</code> we defined above is equivalent to <a href="https://www.scala-lang.org/api/current/scala/collection/immutable/Stream.html"><code>Stream</code></a> in the Scala standard library. It is now deprecated in favour of <a href="https://www.scala-lang.org/api/current/scala/collection/immutable/LazyList.html"><code>LazyList</code></a>. This is because <code>InfiniteList</code> / <code>Stream</code> always evaluates the head of the list. This makes it easier to implement but causes some problems in practice. The <code>InfiniteList</code> / <code>Stream</code> implementation is implemented in the &quot;odd&quot; style, while <code>LazyList</code> is &quot;even&quot;. This terminology comes from <a href="https://www.diva-portal.org/smash/get/diva2:413532/FULLTEXT01.pdf">How to add laziness to a strict language without even being odd</a>, which describes the problem and the solution in more detail.</p>
            <p><a href="https://edward-huang.com/functional-programming/algorithm/programming/scala/2020/08/02/wtf-is-corecursion/">WTF is Corecursion</a> is a very accessible introduction to corecursion that uses Scala. <a href="https://www.cl.cam.ac.uk/archive/mjcg/plans/Coinduction.html">Corecursion and coinduction: what they are and how they relate to recursion and induction</a> has much more detail but is still quite readable. <a href="https://dl.acm.org/doi/pdf/10.1145/289423.289455">The Under-Appreciated Unfold</a> goes into detail of <code>unfold</code>, which is the corecursive equivalent of <code>fold</code>. Finally, <a href="https://www.cs.ox.ac.uk/ralf.hinze/publications/CEFP09.pdf">Reasoning about Codata</a> has more theory while remaining somewhat readable without a large amount of specialist background.</p>
            <p class="nextPage"><a href="../references.html">References→</a></p>
        </main>
        <footer>Creative Scala is copyright Noel Welsh</footer>
    </div>

    </div>
</body>

</html>